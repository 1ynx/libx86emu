x86 emulation library
=====================


Global Variables
----------------

- emulator state

  x86emu_t x86emu;


Interface Functions
-------------------

- set callback function that handles memory and io accesses

  void x86emu_set_memio_func(x86emu_t *emu, x86emu_memio_func_t func);

  typedef unsigned (* x86emu_memio_func_t)(u32 addr, u32 *val, unsigned type);

  - type: one of
    X86EMU_MEMIO_8
    X86EMU_MEMIO_16
    X86EMU_MEMIO_32

    + one of

    X86EMU_MEMIO_R
    X86EMU_MEMIO_W
    X86EMU_MEMIO_X
    X86EMU_MEMIO_I
    X86EMU_MEMIO_O


- set interrupt handler

  void x86emu_set_intr_func(x86emu_t *emu, unsigned num, x86emu_intr_func_t handler);

  typedef int (* x86emu_intr_func_t)(x86emu_t *emu, u8 num, unsigned type);

  - type:
    INTR_TYPE_SOFT
    INTR_TYPE_FAULT

    + bitmask of

    INTR_MODE_RESTART
    INTR_MODE_ERRCODE

If defined, the interrupt handler is called at the start of the interrupt
handling procedure. The handler should return 1 to indicate the interrupt
handling is complete and the emulator can skip its own interrupt processing
or 0 to indicate the emulator should start the normmal interrupt processing.


- execution hook

  void x86emu_set_code_check(x86emu_t *emu, x86emu_code_check_t func);
  typedef int (* x86emu_code_check_t)(x86emu_t *emu);

If defined, the function is called before a new instruction is decoded and
emulated. If logging is enabled the current cpu state has already been
logged. If the function returns a value != 0, the emulation is stopped.


- memory permissions

  void x86emu_set_perm(x86emu_t *emu, unsigned start, unsigned len, unsigned perm);

  - perm: bitmask of
  X86EMU_PERM_R
  X86EMU_PERM_W
  X86EMU_PERM_X
  X86EMU_ACC_R
  X86EMU_ACC_W
  X86EMU_ACC_X
  X86EMU_ACC_INVALID


- io permissions

  void x86emu_set_io_perm(x86emu_t *emu, unsigned start, unsigned len, unsigned perm);

  - perm: see x86emu_set_perm()


- direct memory access

  void x86emu_set_page_address(x86emu_t *emu, unsigned page, void *address);

  - page: start address of memory page (page size: X86EMU_PAGE_SIZE)

Give x86emu access to memory mapped regions. Works only for hole pages. Note
that memory permissions still apply (x86emu_set_perm()).

If address = NULL, switch back to emulated memory.


- set log buffer

  void x86emu_set_log(x86emu_t *emu, char *buffer, unsigned buffer_size, x86emu_flush_func_t flush);
  typedef void (* x86emu_flush_func_t)(char *buf, unsigned size);

If the log buffer is full, flush() is called (if not NULL).


- clear log
  void x86emu_clear_log(x86emu_t *emu, int flush);

Clear log buffer. If flush != 0, write current log via flush() function (see x86emu_set_log()).


- write to log
  void x86emu_log(x86emu_t *emu, const char *format, ...) __attribute__ ((format (printf, 1, 2)));


- reset cpu state
  void x86emu_reset(x86emu_t *emu);

Does a normal cpu reset (clear registers, set cs:eip).


- start emulation
  unsigned x86emu_run(x86emu_t *emu, unsigned flags);

  - flags:
  X86EMU_RUN_TIMEOUT
  X86EMU_RUN_MAX_INSTR
  X86EMU_RUN_NO_EXEC
  X86EMU_RUN_NO_CODE
  X86EMU_RUN_LOOP

X86EMU_RUN_TIMEOUT: set emu->timeout to max. seconds to run.
X86EMU_RUN_MAX_INSTR: set emu->max_instr to max. instructions to emulate.

Return value indicates why x86emu_run() stopped (see flags).

Note: copies emu to global variable x86emu while running!


- stop emulation
  void x86emu_stop(x86emu_t *emu);

Use this function in callbacks (e.g. interrupt handler) to tell the emulator
to stop. The result is that the emulator returns from x86emu_run() when the
current instruction is finished.


- create new emulation object
  x86emu_t *x86emu_new(unsigned def_mem_perm, unsigned def_io_perm);

def_mem_perm are the default permissions for memory accesses, def_io_perm for io. See
x86emu_set_perm(), x86emu_set_io_perm().

Free object later with x86emu_done().


- delete emulation object
  void x86emu_done(x86emu_t *emu);


- raise an interrupt

  void x86emu_intr_raise(u8 intr_nr, unsigned type, unsigned err);

The interrupt is handled before the next instruction. For type see
x86emu_set_intr_func() above; if INTR_MODE_ERRCODE is set, err is the error
code pushed to the stack.


- dump emulator state
  void x86emu_dump(x86emu_t *emu, int flags);

  - flags:
  X86EMU_DUMP_MEM
  X86EMU_DUMP_ATTR
  X86EMU_DUMP_IO
  X86EMU_DUMP_REGS
  X86EMU_DUMP_INTS

Writes emulator state to log.

